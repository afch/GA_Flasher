//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "Unit1.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TGRA_AND_AFCH_FLASHER *GRA_AND_AFCH_FLASHER;
//---------------------------------------------------------------------------
__fastcall TGRA_AND_AFCH_FLASHER::TGRA_AND_AFCH_FLASHER(TComponent* Owner)
	: TForm(Owner)
{
}
//---------------------------------------------------------------------------






void __fastcall TGRA_AND_AFCH_FLASHER::FlashButtonClick(TObject *Sender)
{
ShowMessage("!");
}
//---------------------------------------------------------------------------

void __fastcall TGRA_AND_AFCH_FLASHER::Timer1Timer(TObject *Sender)
{
int curItem;

curItem = COMPortComboBox->ItemIndex;
GetComPorts(COMPortComboBox->Items, "COM");

COMPortComboBox->ItemIndex = curItem;
}
//---------------------------------------------------------------------------

void __fastcall TGRA_AND_AFCH_FLASHER::GetComPorts(TStrings *aList, String aNameStart)
{
  String vBuf;
  int vRes;
  int vErr;
  int vBufSize;
  int vNameStartPos;
  String vName;

  vBufSize = 1024 * 5;
  vRes = 0;

  while (vRes == 0)
	{
	  setlength(vBuf, vBufSize) ;
	  SetLastError(ERROR_SUCCESS);
	  vRes = QueryDosDevice(NULL, vBuf[1], vBufSize) ;
	  vErr = GetLastError();

	  //for 2000
	  if ((vRes != 0) && (vErr == ERROR_INSUFFICIENT_BUFFER))
		{
		  vBufSize = vRes;
		  vRes = 0;
		};

	  if ((vRes == 0) && (vErr == ERROR_INSUFFICIENT_BUFFER))
		{
		  vBufSize = vBufSize + 1024;
		};

	  if ((vErr != ERROR_SUCCESS) && (vErr != ERROR_INSUFFICIENT_BUFFER))
		{
		  raise Exception.Create(SysErrorMessage(vErr) );
		}
	};
  setlength(vBuf, vRes) ;

  vNameStartPos = 1;
  vName = GetNextSubstring(vBuf, vNameStartPos);

  aList.BeginUpdate();
  try
    aList.Clear();
	while (vName != '')
	  {
        if StartsStr(aNameStart, vName) then
          aList.Add(vName);
		vName = GetNextSubstring(vBuf, vNameStartPos);
	  };
  finally
	aList.EndUpdate();
  end;
end;

String __fastcall TGRA_AND_AFCH_FLASHER::GetNextSubstring(aBuf: string; var aStartPos: integer)
{
  int vLastPos;

  if (aStartPos < 1) raise ERangeError.Create('aStartPos must be greate then 0');


  if (aStartPos > Length(aBuf) )
	{
	  Result = "";
	  Exit;
	}

  vLastPos := PosEx(#0, aBuf, aStartPos);
  Result := Copy(aBuf, aStartPos, vLastPos - aStartPos);
  aStartPos := aStartPos + (vLastPos - aStartPos) + 1;
}
